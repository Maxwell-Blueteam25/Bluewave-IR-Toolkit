<#
.SYNOPSIS
    Bluewave Sweeper (PWSH 7 Edition)
    Runs a portable IOC sweep on Windows systems using PowerShell 7+.

.DESCRIPTION
    This tool performs a forensic sweep for Indicators of Compromise (IOCs) defined in a JSON profile.
    It supports File Names, File Hashes, Registry Keys/Values, and Process Names.
    Designed for scalability, it can report findings locally, to an SMB share, or to Azure Blob Storage.

    WORKFLOW INSTRUCTIONS:
    1.  Fill out the 'template.csv' file with your target IOCs.
    2.  Run the helper script 'Convert-CsvToIoc.ps1' against that CSV.
    3.  The helper script will output a JSON file (e.g., 'sweeper_config.json').
    4.  Use that generated JSON file as the value for the -InputJson parameter below.

.PARAMETER InputJson
    Path to the JSON configuration file generated by Convert-CsvToIoc.ps1.

.PARAMETER ReportMode
    Destination for the report. Options: 'Local', 'SMB', 'Cloud'.

.PARAMETER SMBPath
    (Optional) UNC Path for SMB upload (e.g. \\Server\Share\Evidence). Required if ReportMode is 'SMB'.

.PARAMETER SasURL
    (Optional) Azure Blob SAS URL with Write permissions. Required if ReportMode is 'Cloud'.

.EXAMPLE
    .\BluewaveSweeper.ps1 -InputJson ".\sweeper_config.json" -ReportMode Local

.EXAMPLE
    .\BluewaveSweeper.ps1 -InputJson ".\sweeper_config.json" -ReportMode SMB -SMBPath "\\192.168.1.50\Uploads"

.EXAMPLE
    .\BluewaveSweeper.ps1 -InputJson ".\sweeper_config.json" -ReportMode Cloud -SasURL "https://storage.blob.core.windows.net/..."
#>
function Invoke-Sweep {
    param(
        [Parameter(Mandatory = $true)]
        [string]$InputJson,
        [Parameter(Mandatory = $false)]
        [string]$ReportMode,
        [string]$SMBPath,
        [string]$SasURL
    )
    
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    $MasterReport = @()

    if (-not (Test-Path $InputJson)){
        Write-Error "Profile not found"; exit
    }

    try {
        $ConfigObject = Get-Content $InputJson -Raw | ConvertFrom-Json -ErrorAction Stop
        Write-Host "Config Valid. Deployment Started." -ForegroundColor Green
    } catch {
        Write-Error "JSON Validation Failed: $_"
        exit
    }

    foreach ($SweepItem in $ConfigObject.sweeps) {
        
        $Result = $null 

        if ($SweepItem.type -eq "registry_value"){
            Write-Host "Checking Registry Value: $($SweepItem.value)" -ForegroundColor Cyan
            $Result = Invoke-RegistryModule -reg_value $SweepItem.value -constraints $SweepItem.constraints
        } 
        elseif ($SweepItem.type -eq "file_hash") {
            Write-Host "Checking Hash: $($SweepItem.value)" -ForegroundColor Yellow
            $Result = Invoke-HashModule -hash_value $SweepItem.value -constraints $SweepItem.constraints
        } 
        elseif ($SweepItem.type -eq "registry_key"){
            Write-Host "Checking Registry Key: $($SweepItem.value)" -ForegroundColor Cyan
            $Result = Invoke-RegistryModule -reg_key $SweepItem.value -constraints $SweepItem.constraints
        } 
        elseif ($SweepItem.type -eq "process_name") {
            Write-Host "Checking Process: $($SweepItem.value)" -ForegroundColor Magenta
            $Result = Invoke-ProcessModule -process_value $SweepItem.value
        } 
        elseif ($SweepItem.Type -eq "file_name") {
            Write-Host "Checking File Name: $($SweepItem.value)" -ForegroundColor Yellow
            $Result = Invoke-FileModule -file_name $SweepItem.value -constraints $SweepItem.constraints
        }

        if ($Result) {
            $MasterReport += $Result
        }
    }

    $ReportName = "Report_$($env:COMPUTERNAME)_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
    $BasePath = if ($PSScriptRoot) { $PSScriptRoot } else { "." }
    $ReportPath = Join-Path -Path $BasePath -ChildPath $ReportName
    
    $MasterReport | ConvertTo-Json -Depth 3 | Set-Content -Path $ReportPath

    switch ($ReportMode) {
        Local { Write-Host "Mode: Local Only. Saved to $ReportPath" -ForegroundColor Gray }
        
        Cloud { 
            
            if (-not $SasUrl){ 
                Write-Host "Cloud Mode requires -SasUrl" -ForegroundColor Red
                return 
            }
            
            Write-Host "Uploading to Azure Blob..." -ForegroundColor Cyan
            
            try {
                
                Add-FileToBlobStorage -file $ReportPath -connectionstring $SasUrl
                
                Write-Host "Success: Uploaded to Azure" -ForegroundColor Green
            } catch {
                Write-Error "Failed to upload to Azure: $($_.Exception.Message)"
            }
        }
        
        SMB { 
            if (-not $SMBPath) { 
                Write-Host "SMB Path Missing" -ForegroundColor Red
                return 
            }
            
            Write-Host "Uploading to SMB Share..." -ForegroundColor Cyan    
            try {
                Copy-Item -Path $ReportPath -Destination $SMBPath -ErrorAction Stop
                Write-Host "Success: Copied to $SMBPath" -ForegroundColor Green
            } catch {
                Write-Error "Failed to copy to SMB: $($_.Exception.Message)"
            }
        }
    }
    
    Write-Host "Sweep Complete." -ForegroundColor Green
}

function Invoke-RegistryModule {
    param(
        [Parameter(Mandatory=$false)]
        [String]$reg_value,

        [Parameter(Mandatory=$false)]
        [String]$reg_key,

        [Parameter(Mandatory=$false)]
        [PSCustomObject]$constraints
    )

    $SearchPath = if ($constraints.path) { $constraints.path } else { $reg_key }

    if ($reg_value) {
        try {
            $Item = Get-ItemProperty -Path $SearchPath -Name $reg_value -ErrorAction Stop
            if ($Item) {
                Write-Host "HIT: Registry Value $reg_value found in $SearchPath" -ForegroundColor Red
                return [PSCustomObject]@{
                    HostName  = $env:COMPUTERNAME
                    Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                    Type      = "registry_value"
                    Value     = $reg_value
                    Status    = "DIRTY"
                    Details   = "$SearchPath (Value: $reg_value)"
                }
            }
        } catch {
            Write-Host "CLEAN: Registry Value $reg_value not found" -ForegroundColor Green
            return [PSCustomObject]@{
                Hostname  = $env:COMPUTERNAME
                Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                Type      = "registry_value"
                Value     = $reg_value
                Status    = "CLEAN"
                Details   = $null
            }
        }
    } else {
        if (Test-Path $SearchPath) {
            Write-Host "HIT: Registry Key $SearchPath found" -ForegroundColor Red
            return [PSCustomObject]@{
                HostName  = $env:COMPUTERNAME
                Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                Type      = "registry_key"
                Value     = $reg_key
                Status    = "DIRTY"
                Details   = $SearchPath
            }
        } else {
            Write-Host "CLEAN: Registry Key not found" -ForegroundColor Green
            return [PSCustomObject]@{
                Hostname  = $env:COMPUTERNAME
                Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                Type      = "registry_key"
                Value     = $reg_key
                Status    = "CLEAN"
                Details   = $null
            }
        }
    }
}

function Invoke-HashModule {
    param(
        [Parameter(Mandatory=$true)]
        [string]$hash_value,

        [Parameter(Mandatory=$false)]
        [PSCustomObject]$constraints
    )

    $FilesToScan = @()

    if ($constraints.path) {
        $SearchPath = $constraints.path
        if (Test-Path $SearchPath) {
            
            $FilesToScan = Get-ChildItem -Path $SearchPath -File -Force -ErrorAction SilentlyContinue
        }
    } else {
        $SearchPath = "C:\Users\"
        if (Test-Path $SearchPath) {
            
            $FilesToScan = Get-ChildItem -Path $SearchPath -Recurse -File -Force -ErrorAction SilentlyContinue
        }
    }

    if ($FilesToScan) {
        $Hits = $FilesToScan | ForEach-Object -Parallel {
            $fileHash = Get-FileHash -Path $_.FullName -ErrorAction SilentlyContinue
            
            if ($fileHash -and ($fileHash.Hash -eq $using:hash_value)) {
                Write-Host "HIT: Hash Match on $($_.FullName)" -ForegroundColor Red
                
                [PSCustomObject]@{
                    Hostname  = $env:COMPUTERNAME
                    Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                    Type      = "file_hash"
                    Value     = $using:hash_value
                    Status    = "DIRTY"
                    Details   = $_.FullName
                }
            }
        } -ThrottleLimit 10

        if ($Hits) {
            return $Hits
        }
    }

    
    return [PSCustomObject]@{
        Hostname  = $env:COMPUTERNAME
        Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
        Type      = "file_hash"
        Value     = $hash_value
        Status    = "CLEAN"
        Details   = $null
    }
}

function Invoke-ProcessModule {
    param(
        [Parameter(Mandatory=$true)]
        [String]$process_value
    )

    $results = Get-CimInstance -ClassName Win32_Process -Filter "Name='$($process_value)'" -ErrorAction SilentlyContinue
    if ($results) {
        Write-Host "HIT: Process $process_value is running" -ForegroundColor Red
        return [PSCustomObject]@{
            Hostname  = $env:COMPUTERNAME
            Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Type      = "process_name"
            Value     = $process_value
            Status    = "DIRTY"
            Details   = "PID: $($results.ProcessId)"
        }
    } else {
        Write-Host "CLEAN: Process $process_value not found" -ForegroundColor Green
        return [PSCustomObject]@{
            Hostname  = $env:COMPUTERNAME
            Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Type      = "process_name"
            Value     = $process_value
            Status    = "CLEAN"
            Details   = $null
        }
    }
}

function Invoke-FileModule {
    param(
        [Parameter(Mandatory=$true)]
        [String]$file_name,

        [Parameter(Mandatory=$false)]
        [PSCustomObject]$constraints
    )
    
    $SearchPath = if ($constraints.path) { $constraints.path } else { "C:\" }
    
    try {
        $results = Get-ChildItem -Path $SearchPath -Filter $file_name -Recurse -Force -ErrorAction SilentlyContinue
        
        if ($results) {
            Write-Host "HIT: File $file_name found" -ForegroundColor Red
            
            $HitObjects = @()
            foreach ($res in $results) {
                $HitObjects += [PSCustomObject]@{
                    Hostname  = $env:COMPUTERNAME
                    Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                    Type      = "file_name"
                    Value     = $file_name
                    Status    = "DIRTY"
                    Details   = $res.FullName
                }
            }
            return $HitObjects

        } else {
            Write-Host "CLEAN: File $file_name not found" -ForegroundColor Green
            return [PSCustomObject]@{
                Hostname  = $env:COMPUTERNAME
                Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
                Type      = "file_name"
                Value     = $file_name
                Status    = "CLEAN"
                Details   = $null
            }
        }
    } catch {
        Write-Host "Error accessing path" -ForegroundColor Gray
        return [PSCustomObject]@{
            Hostname  = $env:COMPUTERNAME
            Timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Type      = "file_name"
            Value     = $file_name
            Status    = "ERROR"
            Details   = $_.Exception.Message
        }
    }
}
function Add-FileToBlobStorage{
    Param(
        [Parameter(Mandatory=$true)]
        [ValidateScript({Test-Path $_ })]
        [string]
        $file,
        [Parameter(Mandatory=$true)]
        [ValidateScript({$_ -match "https\:\/\/(.)*\.blob.core.windows.net\/(.)*\?(.)*"})]
        [string]
        $connectionstring
    )
    $HashArguments = @{
        uri = $connectionstring.replace("?","/$($(get-item $file).name)?")
        method = "Put"
        InFile = $file
        headers = @{"x-ms-blob-type" = "BlockBlob"}
 
    }
    Invoke-RestMethod @HashArguments
}

